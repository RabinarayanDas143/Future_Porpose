 1. What are Microservices ?
 ================================================
  -> Microservice is an architecture where the application is exposed as loosely copuled services that can be independently 
     developed, deployed and maintained. Each service called as microservice. Each service perform unique function.
  
  -> Speciality of the microservice is that can supported polyglot architecture. For Example if a team is working on one 
     microservice using java, SpringBoot and Mysql , another team can work on other microservice using Python, React and NoSql.
     
  -> Different microservice can use different version of same programming language.
  -> Different microservice can use different programming language.
  -> Different microservice can use different architecture as well.
  
  
 2. Why Microservices ?
 ===============================================
  -> In the case of monolithic application there are several problem like 
       . We have to use same code base in all the module, application is deployed as a single unit.
       . Complex to maintain and find a issue.
       
  -> Each service is independent and give the flexibility to choose the programming language, database
  -> All the service can be developed, deployed and maintained independently.
  
 3. What are the props and cons of Microservice Architecture ?
 =======================================================================
        Props (Advantage)                                                  Cons (Disadvantage)
 ================================================         ================================================================
 1. Freedom to use different language.                    1. Management of a large number of service is difficult.
 2. We microservice focuses on single capability.         2. Communication between microservice is complex.
 3. We can individually deployed different service.       3. Increase effort for configuration .
 4. Allow to frequent software release.                   4. Difficult to maintain transaction safety and data boundaries.
 5. Multiple services are parallelly developed and        5. Its hard to debug.
     deployed. 
                                                          6. Microservice will need large team size to main the application.
                                                          
 4. When to use Microservices ?
 =====================================================================
  - Reduce time to market.
  - Scalable better software.
  - Lower cost.
  - Faster development.
  - Cloud native application.
  - if the team size is big, bcz each service will require it team to develop, deploy and manage.
  - If fast result are requied.
  - Do not use this architecture for simple application.
 
 5. What are the main features of Microservices ?
 ======================================================================
  - Microservices architecture breaks an application in to small services, so that we can develop, deploy and maintained all the 
    services independently.
  - Decentralization : The data management is decentralized. We can use same data base for all services.
  - Black box : Every microservice is defined as a black box. Means payment service does not know anything about order service.
  - Security : We can easily apply security like authentication, authorization for every API call through API Gateway.
  - Polyglot : This is one of the significant feature of microservices. we can develop one service using java then also we 
               can develop other service using python.
              - Different microservices can use different language.
              
 6. How do Microservices communicate with wach other ?
 ======================================================================
  - In Microservice architecture, there are 2 different type of inter-service communication
    - Synchronous communication.
    - Asynchronus communication.
    
 - Synchronous Call
   . In a synchronous call, the caller waits until the process is finished and returns a response.
   . We can do Synchronous call using RestTemplate, Feign Client
   . üëâ Request ‚Üí Wait ‚Üí Response
   Ex:  
        User Service ‚Üí Hotel Service ‚Üí Response
        
          @FeignClient("HOTELSERVICE")
          public interface HotelClient {
          @GetMapping("/hotels/{id}")
          Hotel getHotel(@PathVariable String id);
                   }
                   
       ‚è≥ UserService waits until HotelService responds.
       
 - Asynchronous Call
   . In an asynchronous call, the caller does NOT wait. It continues execution, and the response is handled later.
   . We can do Asynchronous call using Kafka, RebitMq, Active MQ.
   . üëâ Request ‚Üí Continue ‚Üí Response later
   
   Ex:   
        CompletableFuture.runAsync(() -> {
              System.out.println("Task running");
          });

        System.out.println("Main thread continues");
        
        Main thread continues
        Task running
        
        . Order Service ‚Üí Kafka Topic ‚Üí Email Service
        . OrderService does not wait for EmailService.
        
        
 7. Monolithic vs Microservices Architecture
 ===========================================================================
  - A monolithic application is built as one single unit where all components are tightly coupled.
  - Everything is deployed together as one application (one WAR/JAR).
  - In Microservice architecture where an application is split into small, independent services.
        
 8. Types of Async Communication.
 ====================================================================================
  - There are 2 type of comunication 
     1. Point to Point
     2. Publisher - Subscriber
     
  1. Point to Point : A queue is used for this type of comunication.
        The service that produce the message, which is called as producer (sender), it will send the message
        to a queue and other service that has interest in that message which is called consumer (receiver), it will
        consume that message from the queue and it start the process.
        - In point-to-point, one service sends a message/request to exactly one specific service.
        Ex: popular choice for the queue system is RabiMQ and ActiveMQ.
        
        üîπ How it works

            Sender knows the receiver
            One request ‚Üí one response (or one consumer)
            Can be synchronous or asynchronous
        
  2. Publisher - Subscriber : In Publisher-Subscriber based communication the Topic is used by the message broker to
           store the message.
           In that case the publisher publish one topic and then the subscriber to subscribe that topic then process it.
           - In pub-sub, a service publishes an event, and multiple services can subscribe to it.
           - Ex: popular choice for the topic system is Kafka, AWS SNS
           
                      ‚îå‚îÄ‚îÄ‚ñ∫ Email Service
         Order Service ‚îÄ‚îÄ‚ñ∫ Kafka Topic
                      ‚îî‚îÄ‚îÄ‚ñ∫ Notification Service
                      ‚îî‚îÄ‚îÄ‚ñ∫ Analytics Service
                      
            üîπ How it works

                Publisher does not know subscribers
                Event-driven
                Asynchronous only
                Uses topics
                
                
 9. When to use which communication (Sync & Async) .
 ==================================================================================
  - When we start the application from scratch go with Synchronous communication to optimize for speed evolution.
  - When Microservice architecture grows and start becoming complex then focus on switch t Asyncghronous communication.
  - If the response is not necessary to proceed with other functionality then convert the communication channel to Async communication.
  
 10. What is Saga Pattern ?
 ========================================================================
  Why Saga ?
  --------------------------------------------------
  -> The problem started when we moved from Monolithilc application to Microservice acrchitecture.
  -> Ex: Swiggy, Zomato.
         . Choose your dishes
         . Add them cart
         . Make Payment
         . Order get delivered.
         . Our order is marked as completed after delivery successful.
     -> In Monolithic its not a problem because we have 1 DB , multiple tables like Order, Payment, Delivery etc. 
        Now 1 single Atomic transaction we can do all these steps and if payment fails, everything get rolled back.
        
  -> Now we moved to Microservice architecture and Split our application in to a Small Small services.
         . Order Service
         . Payment Service
         . Delivery Service
  -> Now your Order service accept your order, payment service validate the payment done and delivery service is responsible 
     for delivery your order.
  -> Now take a case if Delivery is failed as no delivery partner was available but your payment is done and money is also deducted
     and now no food. Now we want get back the money and order must be mark as cancelled.
  -> For that we have to Roll back the Transaction but the scope of transaction was in Delivery service. The boundary for this 
     this transaction ended in delivery service.
  -> Now the money is not returned also your order status is changed from waiting to failed or cancelled. Now this is Big problem.
  -> To Overcome that type of issue we use Saga Design pattern.
  
  What is the Saga Design Pattern?
  -----------------------------------------------------------------------------
  -> The saga design pattern is architecture of Microservice. It is used to manage the distributed transaction in Microservice instead of single transaction.
  -> A saga breaks the transaction in to a sequency of local transaction.
  -> Each local transaction updates its own database and then triggers the next step.
  -> Types of Saga Pattern
  
        1Ô∏è. Choreography-based Saga(Event-Driven)
        --------------------------------------------------------------------
          - No central coordinator
          - Each service listens to events and reacts
          
           Order Service ‚Üí Payment Service ‚Üí Inventory Service
           
           Order Created
           Payment Service processes payment
           Inventory Service reserves stock
           If payment fails ‚Üí Order is cancelled
           
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ Order Service‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ OrderCreated Event
                  ‚ñº
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇPayment Servic‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ PaymentSuccessful Event
                  ‚ñº
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇInventory Serv‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ StockReserved Event
                  ‚ñº
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ Shipping Serv‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           
          ‚ùå Failure Scenario (Compensation)
          
          Inventory Service ‚ùå fails
                  ‚îÇ
                  ‚ñº
         Payment Service ‚Üí Refund Payment
                  ‚îÇ
                  ‚ñº
         Order Service ‚Üí Cancel Order
         
         üìå Key Point:
                      Each service listens to events and decides next action
                      
                      
             Order Service finishes its work
                       |
                       | publishes event: OrderCreated
                       v
             Payment Service hears the event
                       |
                       | decides by itself: ‚ÄúI should do payment‚Äù
                       v
           Inventory Service hears PaymentSuccess
                       |
                       | decides by itself: ‚ÄúI should reserve stock‚Äù
                       
            Important point üîë
                 No service says ‚Äúyou do this next‚Äù
                 Each service only:
                           Listens to events
             
                      
        2Ô∏è. Orchestration-Based Saga (Central Controller)
       --------------------------------------------------------------------
       
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ Saga Orchestrator ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ Create Order
                 ‚ñº
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ Order Service     ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ Process Payment
                 ‚ñº
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ Payment Service   ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                 ‚îÇ Reserve Stock
                 ‚ñº
       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
       ‚îÇ Inventory Service ‚îÇ
       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       
       ‚ùå Failure Scenario (Compensation)
       
       Inventory Service ‚ùå fails
              ‚îÇ
              ‚ñº
       Saga Orchestrator
              ‚îÇ
              ‚îú‚îÄ‚îÄ> Payment Service ‚Üí Refund Payment
              ‚îÇ
              ‚îî‚îÄ‚îÄ> Order Service ‚Üí Cancel Order
              
       üìå Key Point:
             Orchestrator:
                 Decides order of execution
                 Triggers compensation on failure
                 
                 
          Saga Orchestrator (Team Lead)
                     |
                     | tells Order Service: Create Order
                     v
          Order Service completes
                     |
                     | Lead tells Payment Service: Do Payment
                     v
          Payment Service completes
                     |
                     | Lead tells Inventory Service: Reserve Stock
          
          Important point üîë
              Services do not decide
              They only follow commands
              All logic is inside the orchestrator
              
 11. How to Design and implement Microservice
 =============================================================================
 1Ô∏è-> Design a Microservice (Before Writing Code) 
 ----------------------------------------------------------
    Step 1: Identify Business Capability
            A microservice should represent ONE business responsibility.   
            
            Example (E-commerce):
                         Order Service
                         Payment Service
                         Inventory Service
                         User Service
                  üìå Rule:
                      One microservice = one business capability
                      
    Step 2: Define Service Boundaries
                     Each microservice must:
                           Have its own database
                           Be independently deployable
                           Not share DB tables
                           
   Step 3: Define APIs (Contract First)
   
   Step 4: Decide Communication Style
                      Choose one:
                           REST (Sync)
                           Messaging (Async)
                           
   Step 5: Decide Data Consistency Strategy
                  Use Saga pattern for multi-service transactions
                  
   2Ô∏è-> Implement a Microservice (Spring Boot Example)
  --------------------------------------------------------------------------------
     Step 6: Create Spring Boot Project
     Step 7: Layered Architecture
                      Controller ‚Üí Service ‚Üí Repository ‚Üí Database
     Step 8: Implement REST Controller
     Step 9: Business Logic (Service Layer)
     Step 10: Database Layer
     
  3Ô∏è-> Make It Production-Ready (Very Important)
 ---------------------------------------------------------------------------------
     Step 11: Configuration Management                      
     Step 12: Service Discovery
     Step 13: API Gateway
     Step 14: Fault Tolerance
     Step 15: Logging & Monitoring
     
  To design a microservice, I first identify a single business capability, define its API and database, choose communication style, 
  and ensure independent deployment. For implementation, I use Spring Boot with layered architecture, externalized config, 
  service discovery, fault tolerance, and containerized deployment.  
  
  
 12. Can you please provide the example scenario where using microservice over monolithic system and vice versa.
 ================================================================================================================================
  -> Monolithic architecture is preffered
    . When limited complexcity.
    . Limited users (employees only)
    . Simple workflows
    . Rare feature changes
    . Strong transactional consistency
    
  -> Microservice architecture is preffered
    . Millions of users
    . High traffic during sales (Big Billion Days)
    . Multiple independent business domains
    . Frequent feature releases
    . Different scaling needs
    
 13. How do you make sure a Microservice application can handel more users as it become popular.
 =====================================================================================================================
   1Ô∏è-> Horizontal Scaling (MOST IMPORTANT)
                 What it means :
                         Run multiple instances of the same microservice
                         Add more instances when traffic increases

   2Ô∏è-> Load Balancing
            A Load Balancer distributes traffic evenly.
            
   3Ô∏è-> Service Independence (Key Microservice Advantage)
           Scale only Product Service
           Don‚Äôt touch Payment Service
           
   4-> Asynchronous Communication
            Synchronous calls block threads.
            
   5-> API Gateway
            Single entry point
            Authentication
            Routing
            
 As a microservice application grows, we handle more users by horizontally scaling services, using load balancers, 
 caching frequently accessed data, making communication asynchronous, auto-scaling with Kubernetes, and monitoring the system continuously.
 This ensures high availability, performance, and fault isolation.
 
 14. How to handel data consistency in microservice
 ========================================================================================
  -> Saga Pattern (MOST IMPORTANT)
         A Saga is a sequence of local transactions.
         Each step updates its own database and publishes an event.
         
  -> Event-Driven Architecture
         Services communicate via events
         Loose coupling
         
  The most common approach is the Saga pattern, it handel the distributed transaction, it break the sequency of transaction 
  in local transaction. if any step fail then it rollback the all process.	
  We also use event-driven communication,
  
 15. Difference between Saga and 2 phase commit
 =========================================================================================
           2 phase Commit                                  Saga Pattern
  ---------------------------------------    -------------------------------------------------------
  -> Strong consistency.                     -> Eventual consistency
  -> Synchronous.                            -> Asynchronous.
  -> Blocking in nature.                     -> Non blocking in nature.
  -> Perfomance is low.                      -> Perfomance is high.
  -> It is a tight copuling.                 -> It is a loose copuling.
  -> Strong data consistency.                -> Temporarily inconsistency.
  
 16. Details of 2 Phase Commit
 =============================================================
 -> Two-Phase Commit (2PC) is a distributed transaction protocol used to ensure atomicity (all-or-nothing) across multiple services or databases.
    . Prepare stage
    . Commit stage
    
 ->  Why do we need 2PC?
    . In a distributed system, a single transaction may span multiple services or databases.
      
     Example Problem (Without 2PC)
     
           Order Service saves order ‚úÖ
           Payment Service deducts money ‚úÖ
           Inventory Service fails ‚ùå

           ‚û°Ô∏è System becomes inconsistent
           
         2PC solves this problem
         
         üë• Main Components

              Coordinator (Transaction Manager)
                   Controls the transaction
                   Decides commit or rollback
              Participants (Resource Managers)
                   Databases / microservices
                   Follow coordinator‚Äôs instructions
                   
       ‚úÖ Phase 1: Prepare Phase (Voting Phase)

                 Coordinator asks all participants:
                 "Can you commit?"
                 
       ‚úÖ Phase 2: Commit Phase
                   Case 1: All say YES
                             Coordinator sends COMMIT
                             Participants commit changes
                             Release locks

                   Case 2: Any says NO
                            Coordinator sends ROLLBACK
                            Participants undo changes
                            Release locks
                            
        Transfer ‚Çπ1000 from Account A to Account B
              Participants
                          Bank A DB
                          Bank B DB

              Flow
                  Prepare:
                         Bank A: Can debit ‚Çπ1000? ‚Üí YES
                         Bank B: Can credit ‚Çπ1000? ‚Üí YES
                  Commit:
                        Debit Account A
                        Credit Account B
                        
        ‚úÖ Advantages of 2PC
               ‚úîÔ∏è Strong consistency
               ‚úîÔ∏è ACID compliance
               
        ‚ùå Disadvantages of 2PC
                ‚ùå Blocking protocol
                   If coordinator crashes ‚Üí participants wait
                ‚ùå Poor scalability
                   Locks held for long time
      
 
 
  Transaction :
  ------------------------------------------------
  -> A transaction is sequency of action that must be executed step by step, if one step is fail the entire steps is must be roll back.
  -> A transaction has following the ACID properties.
     - Atomicity (All or Nothing) : üëâ A transaction is treated as one single unit.
                 Either all operations succeed
                 Or all operations fail and rollback
                 
                 Example
                         Money transfer ‚Çπ1000:
                         Debit from Account A ‚úÖ
                         Credit to Account B ‚ùå (fails)
                         ‚û°Ô∏è Rollback debit ‚Üí no partial update
                         ‚úîÔ∏è No half-completed transactions
                         
     - Consistency (Data Must Follow Rules) : üëâ A transaction must move the database from one valid state to another.
                     All constraints, rules, triggers must be satisfied
                     No corruption of data
                     
                     Example
                             Account balance cannot be negative
                             Primary key must be unique
                             If a transaction violates rules ‚Üí rollback
                             ‚úîÔ∏è Database integrity maintained
                             
                             
    - Isolation (Transactions Don‚Äôt Interfere) : üëâ Multiple transactions can run concurrently without affecting each other.
                                                 Each transaction behaves as if it is the only one running.
                                                 
    - Durability (Once Committed, Always Saved) : üëâ After a transaction commits, data will not be lost, even if:
                                                  System crashes
                                                  Power failure
                                                  Server restarts
                                                  
    Advantages of 2PC
    ------------------------------
    ‚úîÔ∏è Strong consistency
    ‚úîÔ∏è ACID compliance
    ‚úîÔ∏è Simple concept
    
    Disadvantages of 2PC
    -------------------------------
    ‚ùå Blocking protocol
    ‚ùå Poor scalability
                                                  
                                                  
  Transaction in Monolithic Vs Microservice
  ------------------------------------------------------------------------
  -> In monolithic applications, transactions are easy because all operations happen in a single database using ACID transactions.
     In microservices, transactions are distributed across services, so we use Saga pattern with compensating transactions instead 
     of traditional database transactions.
      
      Monolith ‚Üí @Transactional
      Microservices ‚Üí Saga
      Strong consistency ‚Üí Monolith
      Scalability ‚Üí Microservices
      
        
 17. Details of 3 Phase Commit
 ===============================================================================      
  -> 3PC is a distributed transaction protocol that improves Two-Phase Commit (2PC) by reducing blocking.
  -> üëâ It adds one extra phase so that participants don‚Äôt wait forever if the coordinator crashes.
  
  ü§î Why 3PC was introduced?
     Problem in 2PC
        . If Coordinator crashes after PREPARE
        . Participants wait forever
        . System gets blocked
        
      ‚û°Ô∏è 3PC solves this by adding a middle phase
      
  1Ô∏è- Can-Commit Phase (Voting Phase)
        
     Coordinator asks:
                  ‚ÄúAre you able to commit?‚Äù
                  
    Participants:
                  Check resources
                  Reply YES or NO
                  
  2Ô∏è- Pre-Commit Phase (Ready Phase)
  
     If all say YES:
                    Coordinator sends PRE-COMMIT
                    
     Participants:
                   Write transaction to log
                   Lock resources
                   Get ready to commit
                   
  3Ô∏è- Do-Commit Phase (Final Commit)
  
     Coordinator sends COMMIT
     
     Participants:
                  Commit changes
                  Release locks
                  Send ACK
                  
                  
 Example: 
 
        Step-by-Step
        
                    Phase 1 ‚Äì Can Commit?

                            A: Enough balance? ‚Üí YES
                            B: Account valid? ‚Üí YES

                    Phase 2 ‚Äì Pre-Commit

                            Both lock accounts
                            Both write logs
                            Both ready to commit

                Phase 3 ‚Äì Commit

                            Debit A
                            Credit B
                            Release locks
                  
                   ‚úîÔ∏è Transaction successful
                   
    üí• Failure Handling (Key Benefit)
                Coordinator crashes after Pre-Commit
                Participants know commit will happen
                They can commit on their own
                No indefinite waiting
                
   Three-Phase Commit is an extension of Two-Phase Commit that adds a pre-commit phase to avoid blocking when the coordinator fails.
   
   2PC ‚Üí Prepare ‚Üí Commit
   3PC ‚Üí Can-Commit ‚Üí Pre-Commit ‚Üí Commit
   
   
18. What is Circuit Breaker Pattern?
 ====================================================================
 -> The Circuit Breaker pattern is used in microservices to prevent cascading failures.
    Cascading Failure - One failure causes multiple services to fail one after another
    üëâ If one service is failing, we stop calling it for some time instead of retrying again and again.
    
    üíª Microservice Example (Simple)

              Services:
                       Order Service
                       Payment Service
                       
       Problem (Without Circuit Breaker)
                     Payment service is down ‚ùå
                     Order service keeps calling it ‚ùå
                     Threads get blocked
                     Whole system slows down ‚ùå
        
       ‚úÖ Solution: Circuit Breaker
                    Detect failures
                    Stop calling Payment Service
                    Return fallback response
                    Try again later
                    
       üîÑ Circuit Breaker States
               1Ô∏è- Closed (Normal State)
                       All requests go through
                       Failures are counted
                       
                       Request ‚Üí Payment Service
                       
               2Ô∏è- Open (Service is Broken)
                             Too many failures
                             Circuit opens
                             Requests fail immediately
                             
                       Request ‚úñ Payment Service
                       Response ‚Üí Fallback
                       
               3Ô∏è‚É£ Half-Open (Testing State)
                                  After wait time
                                  Send few test requests
                                  If success ‚Üí Close
                                  If failure ‚Üí Open again
                                  
   for Implement
   -----------------------
   we have to add dependency : resilience4j-spring-boot2
   configure in our properties file : 
                                     resilience4j:
                                        circuitbreaker:
                                               instances:
                                                   paymentService:
                                                   failure-rate-threshold: 50
                                                   minimum-number-of-calls: 5
                                                   wait-duration-in-open-state: 30s
                                                   permitted-number-of-calls-in-half-open-state: 2
                                                   sliding-window-size: 10
                                                   
     @CircuitBreaker(name = "paymentService", fallbackMethod = "paymentFallback")
     @GetMapping("/order")
     public String placeOrder() {
        return restTemplate.getForObject(
            "http://PAYMENT-SERVICE/pay",
            String.class
        );
    }

    public String paymentFallback(Exception e) {
        return "Payment service is currently unavailable. Please try later.";
    }
                                     
 
19. How are Microservices Flexible with Spring Cloud?
=========================================================================================
 -> Microservices are flexible with Spring Cloud because Spring Cloud provides ready-made tools that make microservices 
    easy to build, scale, change, and manage independently.
    
    1Ô∏è- Centralized Configuration (Spring Cloud Config)
    2Ô∏è- Service Discovery (Netflix Eureka Service)   
    3Ô∏è- Load Balancing (Spring Cloud LoadBalancer)    
    4Ô∏è- Fault Tolerance (Circuit Breaker ‚Äì Resilience4j)     
    5Ô∏è- API Gateway (Spring Cloud Gateway)  
    6Ô∏è- Independent Deployment   
    
 -> Spring Cloud makes microservices flexible by providing tools for centralized configuration, service discovery,
    load balancing, fault tolerance, and API gateway, allowing services to be developed, deployed, and scaled independently.  
                       
                       
 20. What is Service Registration & Discovery?
 =========================================================================================
-> Service Registration & Discovery allows microservices to dynamically register themselves and discover other
   services without hard-coded it.
   
    . Register ‚Üí ‚ÄúI exist‚Äù
    . Discover ‚Üí ‚ÄúWhere are you?‚Äù
-> How It Works (Step by Step)

    1Ô∏è‚É£ Service Registration
            When a service starts:
               It registers itself in a Service Registry
            Sends:
                 Service name
                 IP address
                 Port
                 
            PAYMENT-SERVICE ‚Üí Eureka Server
            
    2Ô∏è‚É£ Service Discovery
               When another service wants to call it:
                            It asks the Service Registry
                            Gets the service location
                            
               ORDER-SERVICE ‚Üí Eureka ‚Üí PAYMENT-SERVICE
               
       Payment Service
              |
              |  register
              ‚Üì
      Service Registry (Eureka)
              ‚Üë
              |  discover
         Order Service
         
   Tools Used (Spring Cloud)
   --------------------------------
   - Eureka, Consul, Zookeeper
   
 21. Netflix Eureka
 ========================================================================
 -> Netflix Eureka is a Service Registry & Discovery tool used in Microservices architecture.
 -> It helps to services are register themselves and find each other automatically
    Why Do We Need Eureka?
    ----------------------------
       In microservices:
                  Services run on different ports
                  Instances scale up/down dynamically
                  IPs change frequently
               ‚ùå Hardcoding URLs is impossible
               ‚úÖ Eureka solves this 
               
    üîπ Key Components
            1Ô∏è- Eureka Server
                     Central service registry
                     Keeps track of all running services
            2Ô∏è- Eureka Client
                    Microservices that:
                          Register themselves
                          Discover other services
  Implementation
  ----------------------------
     Client implementation
  --------------------------------------
       <dependency>
          <groupId>org.springframework.cloud</groupId>
             <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
       </dependency>
  
    applocation.properties file
    
      spring.application.name=USER-SERVICE
      eureka.client.register-with-eureka=true
      eureka.client.fetch-registry=true
      eureka.client.service-url.defaultZone=http://localhost:8761/eureka/
      
    @SpringBootApplication
    @EnableDiscoveryClient   // optional in Boot 3
    public class UserServiceApplication {
       public static void main(String[] args) {
           SpringApplication.run(UserServiceApplication.class, args);
       }
     }
    
   server implementation
   --------------------------------------
   Dependency:
                   <dependency>
                       <groupId>org.springframework.cloud</groupId>
                            <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
                   </dependency>
                   
   Main class:
                   @EnableEurekaServer
                   @SpringBootApplication
                   public class EurekaServerApplication { }
                   
 22. Microservices Intra-communication
 =====================================================================================
   -> Microservices intra-communication means
     üëâ how one microservice communicates with another microservice inside the same system.
     Ex: When Order Service needs payment status ‚Üí it must talk to Payment Service.
        That communication is called intra-communication.
        
   üîπ Common Ways of Intra-communication
   -----------------------------------------------------
     1Ô∏è- REST API
         Order Service ‚Üí REST call ‚Üí Payment Service
     2Ô∏è- Feign Client (Spring Cloud ‚Äì Recommended) 
          Feign makes REST calls easy and clean.
          
          @FeignClient(name = "PAYMENT-SERVICE")
          public interface PaymentClient {
            @GetMapping("/payment/status/{id}")
               String getStatus(@PathVariable Long id);
          }
          
         ‚úî Clean code
         ‚úî Uses Eureka for service discovery
         ‚úî Supports load balancing
         
    3Ô∏è- Asynchronous Messaging (Kafka / RabbitMQ)
         Services communicate using events, not direct calls.
         Order Service ‚Üí Event ‚Üí Kafka ‚Üí Payment Service
         
          
                   
                     
       
               
            
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 