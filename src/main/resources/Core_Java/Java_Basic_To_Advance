
  OOPS OVERVIEW
 ======================================================
 1. OOPS means object oriented programming.
 2. Here object means real world entities like Car, Bike, ATM etc.
 3. Every object have  properties(State) and Behavior(Function).
    Ex: Dog is an object bcz it has
             - Properties like : Age, Breed, Color etc.
             - Behavior like : Bark, Sleep, eat etc.
 4. Procedural programming Vs OOps
 
                Procedural programming                                  OOps
 -------------------------------------------------        --------------------------------------------
 1. Program is divided in to parts called function.       1. Program is divided in to objects.
 2. Do not provide proper way to hide the data, gives     2. Object provide data hiding, gives important to data.
    important to function and data move freely. 
 3. Overloading is not possible.                          3. Overloading is possible.  
 4. Inheritance is not possible.                          4. Inheritance is possible.
 5. Code reusability does not present.                    5. Code reusability is present.
 6. Example: Pascal, C etc.                               6. Java, C++, Python.


  CLASSES 
 =======================================================
 1. Class  is an blueprint of Object.
 2. To Create a object Class is required.
 3. So class provide the template or blueprint from which object can be created.
 4. From one class we can create multiple object.
 5. To create a class use the keyword "class"

 1st PILLAR OF OOPS - DATA ABSTRACTION
 =========================================================
 1. It hides the internal implementation and only show the essential functionality to the user.
 2. It can achieved through interface and abstract class.
  
  Ex: Car - We only show the break and if we press it , car speed will reduce. But how That is abstracted to us .
  
  Advantage :
     Increase security and confidentiality.
     
  2nd PILLAR OF OOPS - DATA ENCAPSULATION
  =======================================================
  1. Encapsulation bundles the data and the code working on that data in a single unit.
  2. Also known as DATA-HIDING.
  3. Steps to achieve encapsulation :
        . Declare variable of a class as private.
        . Provide public getter and setter to modify and view the value of the variables.
        
  Advantage :
      . Loosely coupled code.
      . Better access control and security.
      
 3rd PILLAR OF OOPS - INHERITANCE
 =========================================================
 1. Capability of a class to inherit properties from their parent class.
 2. It can inherit both function and variables, so we do not have to write them again in child classes.   
 3. Can be achieved using extend keyword or through interface.   
     Types of inheritance : 
         . Single inheritance
         . Mltilevel inheritance
         . Hierarchical inheritance
         . Multiple inheritance - through interface we can resolve the diamond problem.
         
   Advantages :
         . Code reusability.
         . We can achieve Polymorphism using interface.
         
  4th PILLAR OF OOPS - POLYMORPHISM
 ========================================================
 1. Poly means many and Morphism means form.
 2. A same method behaves differently in different situation.
  Ex: 
     - A person can be father, husband, employee etc.
     - Water can be liquid, solid and gas etc.
 3. Types of Polymorphism
     - Compile Time / Static Polymorphism / Method overloading
     - Run Time / Dynamic Polymorphism / Method overriding
     
 WHAT IS JAVA
 ===================================================
 -> Java is a object oriented programming lagnguage.
 -> It provide Object oriented programming.
 -> Also we called as WORA (Write Once Run Anywhere).
 -> It have 3 main components. (Jvm, Jre, Jdk).
 -> JVM : It is a abstract machine, physically it's not exist.
 
    Java Program ---Compiler---> ByteCode ----JVM---> Machine Code -----CPU-----> Output
 -> JVM is platform dependent.
 -> JVM have JIT (Just in Time) Compiler. This is use to compile the java code.
 
 -> JRE : JVM + Class libraries
 -> JDK : JVM+JRE
 -> JVM+JRE+JDK all are platform dependent.
 -> Once our java code converted in to byte code, this byte code is platform independent.
 
+--------------------------------------------------+
|                     JDK                          |
|  (Java Development Kit)                          |
|                                                  |
|  +--------------------------------------------+  |
|  |                    JRE                     |  |
|  |   (Java Runtime Environment)               |  |
|  |                                            |  |
|  |   +------------------------------------+   |  |
|  |   |                JVM                 |   |  |
|  |   |      (Java Virtual Machine)         |   |  |
|  |   |                                    |   |  |
|  |   |  - Class Loader                    |   |  |
|  |   |  - Memory Areas                    |   |  |
|  |   |  - Execution Engine                |   |  |
|  |   +------------------------------------+   |  |
|  |                                            |  |
|  |   + Java Libraries (rt.jar etc.)           |  |
|  +--------------------------------------------+  |
|                                                  |
|  + Development Tools                            |
|    - javac                                     |
|    - java                                      |
|    - javadoc                                   |
|    - jar                                       |
|    - debugger                                  |
+--------------------------------------------------+

 -> JSE : Java Standard Edition
    JEE : Java Enterprise Edition
    JME : Java Micro Edition
    
-> main() is the entry point of program.
-> Java code ---compiler----->byte Code ------>JVM call main().
-> public static void main()
-> main() : method name that is call by jvm.
-> void : means this method is not return anything.
-> static : means this method is call directly, with out using object.
-> public : it can be call anywhere.

 WHY ONLY 1 PUBLIC CLASS IN JAVA FILE
 =================================================================================
  -> Java program starts from main() and main() always inside public class. so JVM call this method outside directly.
  -> public class name should be same as file name.
  
 WHAT IS VARIABLE
 ======================================================================
 -> Variable is a container which hold a value.
    EX: Datatype variableName = value;
 -> Java is static type language . Means it declare which type of data it can store.
 -> Strong typed language. Means when we store the value it has some restriction, some range for that.
 -> Variable name is case sensitive.
 -> Variable name can be any legal identifier, means can contain Unicode letters and digits.
 -> Variable name can start is $,_ and letters.
 -> Variable name can not be reserved keyword. like new, class, while, for, interface, int float etc.
 -> Variable should be small if it contains only 1 word else camel case should be followed.
 -> For constant, variable name should be define in capitalletters.
 
 DATA TYPE
 ================================================================
 -> In Java there are 2 type of data type present.
    . primitive type (8 type)
    . Non primitive type.
-> Primitive type :
     . char - 2 byte (16 bits)
     . byte - 1 byte (8 bits)
     . short - 2 byte (16 bits)
     . int - 4 byte (32 bits)
     . long - 8 byte (64 bits)
     . float - 4 byte (32 bits)
     . double - 8 byte (64 bits)
     . boolean - 1 bit. true/false;
     
 TYPE OF CONVERSION
 ===================================================================
 1. Widening/ Automatic conversion. (Convert lower data type to higher data type)
 2. Narrowing / Downcasting/ Explicit conversion. (Convert higher data type to lower data type)
 
 KIND OF VARIABLE
 ================================================================
 - local  : define inside method.
 - Instance : define inside class outside method.
 - static/instance variable : define inside class but outside method , use static keyword. It belongs to class so every object take a reference of that variable.
 - method parameter : we pass some argument in method parameter this is method parameter.
 - Constructor parameter : what are the argument pass in constructor this is called constructor parameter.
 - member variable : define inside class but outside method
 
 REFERENCE DATA TYPE
 ===========================================================
 -> Some of reference data types are : class, String, Array, interface.	
 -> Reference data type means when we create a object of the class it occupy a space in Heap memory and 
    this object is refer to that memory address, so it called Reference.
 -> String are immutable, we can define String using new keyword and using String literals.
 -> When we create string object using new keyword it in Heap memory.
    when we create object using string literal, it store in string constant pool.
    
 WRAPPER CLASS
 ============================================================
 -> Wrapper classes convert primitive data types into objects so they can be used in collections, generics, and object-based APIs.
 
| Primitive Type | Wrapper Class |
| -------------- | ------------- |
| `int`          | `Integer`     |
| `long`         | `Long`        |
| `double`       | `Double`      |
| `float`        | `Float`       |
| `char`         | `Character`   |
| `byte`         | `Byte`        |
| `short`        | `Short`       |
| `boolean`      | `Boolean`     |

 -> Auto-boxing (primitive ‚Üí object)
      int a = 5;
      Integer b = a;  // auto-boxing
      
      int a = 20;
      Integer obj = Integer.valueOf(a);  // boxing
      
-> Unboxing (object ‚Üí primitive)
     Integer x = 10;
     int y = x;  // unboxing
     
     int b = obj.intValue();  // unboxing
     
     
WHAT IS METHODS
=====================================================================================
-> Method is a block of codes that is used to perform certain task.
-> It's a collection of instruction that perform some specific task.
-> It can be used to bring the code readability and re-usability.

 How to declare a method : 
 ------------------------------
         public int sum (int a, int b) throws Exception {
            // Method body
         }
         
 Access Specifier :
 ------------------------------
  public : can be access through any class in any package.
  private : can be access by methods only in the same class.
  protected : can be access by other classes in same package or other sub-classes in different package.
  Default : if we do not mention anything, then default access specifier is used by java. It can be only access in same package.
  
Return Type :
---------------------------------------
- Use class name or primitive data type as return type of the method.

Method Name :
-----------------------------------------
-> It should start with small and follow camel case in case of multiple words.

 Parameter :
 ----------------------------
 -> It's a list of variable that will be used in the methods.
 -> Parameter list can be blank too.
 
 TYPES OF METHODS
 ===================================================
 -> System defined method.
 -> User defined method.
 -> Overloaded method.
 -> Overridden method.
 -> Static methods.
 -> Final methods.
 -> Abstract Methods.
 
 System defined method
 ---------------------------------
 -> Methods which are already defined and ready to use in java like Math.sqrt();
 
 User defined method
 ----------------------------------
 -> Methods which are programmer create based on the business logic.
 
 Overloaded method
 -------------------------------------
 -> More that one method with same name is created in same class.
 
 Overridden method
 -----------------------------------------
 -> Subclass has the same method as the parent class.
 
 Static methods
 ------------------------------------------
 -> These methods are associated with the class.
 -> Can be called with the class name.
 -> static method can not access non static variable and methods.
 -> static method can not be overridden.
 
  When to declare methods statc:
     - Methods which do not modify the state of the object can be declared static.
     - Utility method which do not use any instance variable and compute only on argument.
     Ex: Factory design pattern.
 
 Final methods
 ---------------------------------------------
 -> Final methods can not be overridden.
 -> Final method means its implementation can not be changed. if child class can not be change its implementation then no use of overridden.
 
 Abstract Methods
 -------------------------------------
 -> It is defined only in Abstract class.
 -> Only method declaration is done.
 -> Its implementation is done in child class.
 
 Variable Argument
 ----------------------------------------
 -> Variable number of inputs in the parameter.
 -> Only one variable argument can be present in the method.
 -> It should be the last argument in the list.
 -> It is used when we don't know how much argument is come in method at that time it is used.
    Ex:
        public int sum(int ...var){
           int output = 0;
           for(int i : var){
               output = output+i;
           }
        }
     
     
 JAVA CONSTRUCTOR
 =============================================================
 -> It is used to create an object.
 -> Its similar to method expect: 
        Name : Constructor name is same as class name.
        Return type : Constructor do not have any return type.
        Constructor can not be static or final or abstract, synchronized.
 -> Why constructor do not have return type ?
    -: Constructors don't have a return type because Java implicitly adds return type as class to differentiate them from methods.
 -> Why constructor name is same as of class name?
    -: To identify the constructor among all the methods and constructor defined under the class.
 -> Why constructor cannot be final?
    -:  Constructors can not be inherited. Since it can not be inherited, then what's the use of using Final keyword.
 ->  Why constructor cannot be static?
    -: Constructor initializes the state of an object and needs to access instance variables, so it can't be static,
       as static methods don't have access to instance-specific information. 
 -> Can we define constructor in interface?
    -: An interface, doesn't have instances with state that needs initialization, 
       and it doesn't make sense for an interface to have a constructor.     
 -> Why constructor cannot be abstract?
   -: Constructors can not be inherited. Since it can not be inherited in the child class, then it can not be abstract.   

 Types of Constructor
 -------------------------------------
 - Default
 - No arg
 - Parameterized.
 - Constructor overloaded.
 - private constructor.
 - Constructor chaining.
    . this
    . super

 JAVA MEMORY MANAGEMENT AND GARBAGE COLLECTOR
 ========================================================================================
 -> There are two type of memory
    1. Stack memory
    2. Heap memory
    
 Both Stack and Heap are created in JVM and store in RAM.	
 
 Stack Memory
 -----------------------------------
 -> Store temporary variable and separate memory block for methods.
 -> Store primitive data type.
 -> Store reference of the heap object.
     . Strong reference.
     . Weak reference.
     . Soft reference.
 -> Each threads has its own stack memory.
 -> Variable with in a scope is only visible and as soon as any variable goes out of the scope, it get deleted
    from the stack (in LIFO order)
 -> When stack memory goes full, its throws "java.lang.StackOverflowError"
 
          STACK MEMORY
     (One stack per thread)
     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     |  main() frame       |
     |---------------------|
     |  int a = 10         |
     |  int b = 20         |
     |  ref ‚Üí obj1         |
     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     |  methodA() frame    |
     |---------------------|
     |  int x = 5          |
     |  ref ‚Üí obj2         |
     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
     |  methodB() frame    |
     |---------------------|
     |  int y = 15         |
     |  ref ‚Üí obj3         |
     ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
          ‚Üë TOP (LIFO)

STACK                     HEAP
-----                     -----
ref ‚Üí obj1  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  Object 1
ref ‚Üí obj2  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  Object 2

 
 Heap Memory
 -----------------------------------
 -> It store object.
 -> There is no order of allocating memory.
 -> Garbage collector is used to delete the unreferenced object from the heap.
     . Mark and sweep algorithm.
     . Types of GC 
        - Single GC
        - Parallel GC
        - CMS (concurrent Mark Sweep)
        - G1
 -> Heap memory is shared with all the thread.
 -> Heap also contain the String Pool.
 -> When Heap memory goes full , its throws "java.lang.OutOfMemoryError"
 -> Heap memory is further divided into : 
       . Young Generation (Minor GC happens here)
           - Eden
           - Survivor
       . Old Generation (Major GC happens here)
       
                 HEAP MEMORY
        (Shared across all threads)
        ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ     Young Generation   ‚îÇ
        ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
        ‚îÇ  Eden Space            ‚îÇ
        ‚îÇ  - New objects created ‚îÇ
        ‚îÇ                        ‚îÇ
        ‚îÇ  Survivor Space S0     ‚îÇ
        ‚îÇ  Survivor Space S1     ‚îÇ
        ‚îÇ  - Objects that survive‚îÇ
        ‚îÇ    minor GC            ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ     Old Generation     ‚îÇ
        ‚îÇ  - Long-lived objects  ‚îÇ
        ‚îÇ  - Promoted from young ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   Metaspace (Java 8+)  ‚îÇ
        ‚îÇ  - Class metadata      ‚îÇ
        ‚îÇ  - Methods info        ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       
 JAVA CLASSES
 ===========================================================================
 Concrete class
 ------------------------------------------
 -> Which class we can create object using new keyword is called as Concrete class.
 -> All the method in this class have implementation. 
 -> It can be also your child class from interface or extend abstract class.
 -> A class access modifier can be public or private (no explicit modifier defined).
 
 Abstract Class
 ------------------------------------------
 -> It only showing the essential details to the user and hide the internal implementation.
 -> 2 ways to achieve abstraction
     . Abstract class
     . interface
 -> Class is declared as abstracted through keyword "abstract".
 -> It can have both abstract and non abstract method.
 -> We can not create an instance of the Abstract class.
 -> What ever the features is defined in parent class, all are inherit in child class.
 -> Constructor can be created inside them, and with super keyword from child classed we can access them.
 
 Super and Sub class
 ---------------------------------------------
 -> A class that is derived from super class is called sub class.
 -> And from class through which sub class is derived its called Super class.
 -> If class has no any super class then its super class is Object class.
 -> Object class is the super class of all the class.
 -> It has some common methods like clone(), toString(), equals(), notify(), wait() etc.
 -> Child class object can store in parent class object.
 
 Nested Class
 --------------------------------------------------
 -> Class with in anther class is called Nested class.
 -> When to use ?
    . If a class A is used by only one class B, then instead of creating a separate file A.java, we can
      define A as a nested (inner) class inside class B.
      
class B {

    // Nested class
    class A {
        void show() {
            System.out.println("I am class A");
        }
    }

    void useA() {
        A obj = new A();
        obj.show();
    }
}
 -> It is 2 type 
    . Static Nested Class
    . Non Static Nested Class.
         . Member inner clas
         . Local inner class
         . Anonymous inner class
         
-> Scope : Its scope is same as of its outer class.
 
 Static Nested Class
 -----------------------------------------
 -> It do not have access to the non static instance variable and methods of outer class.
 ->. Its object can be initiated without initiating the object of outer class.
 -> It can be private, public, protected .
 
 class Outer {

    static class Inner {
        void show() {
            System.out.println("Inside static nested class");
        }
    }

    public static void main(String[] args) {
        Outer.Inner obj = new Outer.Inner(); // no Outer object needed
        obj.show();
    }
}
 
 -> Class with private access modifier:
    nested class object can be created with in the same class itself.
    
 Inner class or Non Static Nested class
 ---------------------------------------------------
 -> It have access to all the instance variable and method of outer class.
 -> Its object can be initiated on after initiating the object of outer class.
 -> Member of inner class 
 ---------------------------------------
    -: Its can be private, public, protected, default.
    
Ex:   
class Bank {

    // private nested class
    private class Account {
        void showAccountDetails() {
            System.out.println("Account details shown");
        }
    }

    // method of outer class
    public void display() {
        Account acc = new Account();   // ‚úî allowed
        acc.showAccountDetails();
    }
}

public class Test {
    public static void main(String[] args) {
        Bank bank = new Bank();
        bank.display();

        // ‚ùå Not allowed:
        // Bank.Account acc = bank.new Account();
    }
}
      
  Local inner class
  ------------------------------
  -> Its can be present inside any block like: if block, for loop block those are called Local inner class.
  -> It can not be declared as private, protected, public. Only default access modifier.
  -> It can not be initiated outside of the block.
  
 Anonymous Inner Class :
 -------------------------------------------
 -> An inner class without a name called Anonymous Class.
 -> Why its use:
      - When we want to override the behaviour of the methods without even creating any sub class.
Ex:
abstract class Greeting {
    abstract void sayHello();
}

public class Test {
    public static void main(String[] args) {

        Greeting g = new Greeting() {
            void sayHello() {
                System.out.println("Hello World");
            }
        };

        g.sayHello();
    }
}

 Generic Class in Java
----------------------------------------------------------------------
-> A Generic Class allows you to create a class that can work with any data type ‚Äî without rewriting code.
       üëâ Type-safe
       üëâ No casting needed
       üëâ Reusable code
Ex:
 
class Box<T> {
    private T value;

    void set(T value) {
        this.value = value;
    }

    T get() {
        return value;
    }
}

public class Test {
    public static void main(String[] args) {

        Box<Integer> intBox = new Box<Integer>();
        intBox.set(10);

        Box<String> strBox = new Box<String>();
        strBox.set("Java");

        System.out.println(intBox.get());
        System.out.println(strBox.get());
    }
}
 
  Bound Generic :
     It can be used at generic class and methods.
     - Upper Bound (<T extends Number>) means T can be type of Number or its subclass only. 
     - Multi Bound
     
  ‚úÖ Upper Bound (extends)
  --------------------------------------
class Calculator<T extends Number> {

    double square(T num) {
        return num.doubleValue() * num.doubleValue();
    }
}

public class Test {
    public static void main(String[] args) {

        Calculator<Integer> c1 = new Calculator<Integer>();
        Calculator<Double> c2 = new Calculator<Double>();

        System.out.println(c1.square(5));
        System.out.println(c2.square(2.5));
    }
}

 ‚ùå Calculator<String> ‚Üí Not allowed

‚úÖ Multiple Bounds
-------------------------------------------------
class Test<T extends Number & Comparable<T>> {
}
 üëâ First must be a class, others interfaces
 
 Wildcards:
 ---------------------------------------------------------------------
  Wildcards are used when you don‚Äôt know the exact generic type.
 - Upper bound wild card : <? extends UpperBoundClassName> i.e class name and below
 - Lower bound wild card : <? Super LowerBoundClassName> i.e class name and above
 - Unbounded wildcard <?> only you can read


 POJO CLASS
==========================================================================
 -> Stands for Plain old java object.
 -> contains variables and its getter and setter methods.
 -> class should be public.
 -> public default constructor.
 -> No annotation should be used like @Table, @Entity, @Id etc.
 -> It should be not extend any class or implement any interface.
 
 ENUM CLASS
 ===================================================================
 -> It is a collection of CONSTANTS (variables which value can not be changed).
 -> Its CONTSANTS are static and final implicitly (we do not have to write it).
 -> It can not extend any class, as it internally extends java.lang.Enum class.
 -> It can implement interface.
 -> It can have variable, constructor, methods.
 -> It can not be initiated.
 -> No other class can extend Enum class.
 -> It can have abstract method, and all the contant should implement that abstract method.

 SINGLETON CLASS
 ==========================================================
 -> This class objective is to create only 1 and 1 object.
 -> Different way to create  Singleton class
    . Eager initialization.
      -----------------------------------------  
        public class Singleton {

                // Instance created at class loading time
                private static final Singleton INSTANCE = new Singleton();

               // Private constructor prevents external instantiation
               private Singleton() { }

                // Global access point
               public static Singleton getInstance() {
                     return INSTANCE;
              }
           }
        
        
    . Lazy initialization.
    -------------------------------------------
       public class Singleton {

               private static Singleton instance;

               private Singleton() { }

               public static Singleton getInstance() {
               if (instance == null) {
                     instance = new Singleton();
                   }
                 return instance;
                }
           }
       
    . Synchronization block.
    ------------------------------------------
       public class Singleton {

              private static Singleton instance;

              private Singleton() { }

              public static synchronized Singleton getInstance() {
               if (instance == null) {
                     instance = new Singleton();
                }
             return instance;
           }
        }
       
    . Double check lock.
    ---------------------------------------------------
         public class Singleton {

                 private static volatile Singleton instance;

                private Singleton() { }

                public static Singleton getInstance() {
                    if (instance == null) {              // 1st check
                      synchronized (Singleton.class) {
                           if (instance == null) {      // 2nd check
                             instance = new Singleton();
                         }
                    }
                 }
           return instance;
           }
        }
         
    Why volatile?
       .Prevents instruction reordering
       .Guarantees visibility across threads
    
    . Bill pugh solution.
    -----------------------------------------------------
        public class Singleton {

             private Singleton() { }

             private static class SingletonHelper {
                     private static final Singleton INSTANCE = new Singleton();
              }

             public static Singleton getInstance() {
                 return SingletonHelper.INSTANCE;
              }
          }
          
          Why this is best?
              ‚úî Lazy loaded
              ‚úî Thread-safe
              ‚úî No synchronization overhead
              ‚úî Uses JVM class loading guarantee
     
    . Enum Singleton.
    ---------------------------------------------------------
       enum Singleton {
             INSTANCE;
       }
       
 IMMUTABLE CLASS
 =======================================================================
 -> We can not change the value of an object once it is created.
 -> Declare class as 'final' so that it can not be extended.
 -> All class member should be final and private. so that direct access can be avoided.
 -> And class members are initialized only once using constructor.
 -> There is no setter method only getter method are available.
 -> Ex: String, Wrapper classes etc.
 
     public final class Employee {

            private final int id;
            private final String name;
            private final List<String> employees;

            private final List<String> employees;

            public Employee(int id, String name) {
               this.id = id;
               this.name = name;
               this.employees = new ArrayList<>(employees);
            }

            public int getId() {
                 return id;
            }

            public String getName() {
                  return name;
             }
             
            public List<String> getEmployees() {
                  return new ArrayList<>(employees); 
            }
        }
      

 WHAT IS INTERFACE
 ===========================================================================
 -> Interface is something which helps 2 system to interact with each other, without one system has to know the details of other.
 -> or in simple term i can say, it helps to achieve ABSTRACTION.
 
 hOW to define the abstraction
 ---------------------------------------
  interface declaration consist of
     - Modifiers
     - "interface" keyword
     - interface name
     - Comma separated list of parent interface.
     - Body
     
     only public and default modifiers are allowed (protected and private are not allowed)
     
 why we need Interface ?
 --------------------------------------
 1. ABSTRACTION :
  -> Using interface, we can achieve full abstraction means, we can define what class must do but not how it will do.

 2. Polymorphism :
   -> Interface can be used as a data type .
   -> We can not create the object of an interface, but it can hold the reference of all the classes which implements it.
      And at runtime, it decide which method need to be invoked.
 
 3. Multiple Inheritance :
   -> In java we can achieve multiple inheritance through interface only.
   
   Methods in interface :
    - All methods are implicit public only.
    - Methods can not be declared as final.
    
   Fields in Interface
   -------------------------------
   -> Fields are public, static and final by default.
   -> you can not make field private or protected.
   
  Interface Implementation :
  --------------------------------------
  -> Overriding method can not have more restrict access specifiers.
  -> Concrete class must override all the methods declared in the interface.
  -> Abstract classed are not force to override all the methods.
  -> A class can implement from multiple interfaces.
    
  Nested Interface
 ----------------------------------------
 -> Nested interface declared within another interface.
 -> Nested interface declared with in a class.
 
 
 JAVA 8 AND 9 FEATURES 
 =====================================================================================
 1. Default method(java 8)
 -----------------------------------
 -> Before java8 , interface can have only Abstract method and all child class has to provide the implementation of Abstract method.
 -> Default methods solve this problem by providing a default implementation.
 Ex:
    interface MyInterface {
        default void show() {
        System.out.println("Default method");
      }
    }

 -> Default methods were introduced to add new methods to interfaces without breaking existing implementations.
 
 2. Static Method(java8) :
 ---------------------------------------
 -> We can provide the implementation of the method in interface.
 -> But it can not be overridden by class which implement the interface.
 -> We can access it using interface name itself.
 -> Its by default public.
 Ex:
    interface Utility {

        static void show() {
              System.out.println("Static method in interface");
        }
     }

    public class Test {
          public static void main(String[] args) {
              Utility.show();
        }
     }
    
 3. Private Method and Private static method(java9)
 ------------------------------------------------------
 -> We can provide the implementation of method but as private access modifier in interface.
 -> It bring more readability of the code. for ex: multiple default method share some code,
 -> It can be defined as static and non static.
 -> From static method we can call only private static interface method.
 -> Private static method can be called from both static and non static method.
 -> Private interface method can not be abstract. Means we have to define the definition.
 -> it can be used inside interface only.
 
 What is Functional Interface :
 ==========================================================================
 -> If an interface contains only one abstract method and multiple default and static method is called as functional interface.
 -> Also known as SAM (Single Abstract Method)
 -> @FunctionalInterface keyword can be used at top of the interface (But its optional)
 -> We can implement functional interface through "implements" and through Anonymous Class and through Lambda expression.
 
 
 WHAT IS Lambda Expression
 =========================================================================
 -> Lambda expression is a way to implement the functional interface.
 
 Types of Functional interface
 ====================================================================
 -: Consumer :
 -------------------------------------------------
 -> Represent an operation, that accept a single input parameter and return no result.
 -> present in java.util.function;
 -> It have accept(T t);
    Ex: forEach(); it internally use accept();
 
 -: Supplier
 -------------------------------------------------
 -> Represent the supplier of the result, Accept no input parameter but produce a result.
 -> present in java.util.function;
 -> It have get();
    Ex: generate(); it internally use get();
    
 -: Function
 ---------------------------------------------------
 -> Represent function, that accept one argument process it and produce a result.
 -> present in java.util.function;
 -> It have apply();
    Ex: map(); it internally use apply();
    
-: Predicate
---------------------------------------------------
 -> Represent function, that accept one argument and return the boolean value.
 -> present in java.util.function;
 -> It have test();
    Ex: filter(); it internally use test();
 
 
 What is Reflection ?
 =======================================================================
 -> This is used to examine the classes, methods, fields, interface at runtime and also possible to change the behavior of the class too.
 Ex: 
  -> What all methods, fields present in the class.
  -> What is the return type of the method.
  -> What is the modifier of the class.
  -> What all interfaces class has implemented.
  -> Change the value of the public and private fields of the class etc.
  
  How to do Reflection of Classes ?
  ------------------------------------------------------
  -> To reflect the class, we first need to get an object of Class.
  
    What is class Class
    ----------------------
    - Instance of the class Class represent classes during runtime.
    - JVM creates one Class object for each and every class which is loaded during run time.
    - This Class object, has meta data information about the particular class like its methods, fields, constructor etc.
    
    How to get the particular class Class object ?
   ---------------------------------------------------------
   There are 3 way
   1. Using Class.forName() (Dynamic / Reflection)
       Class<?> cls = Class.forName("java.lang.String");
       
   2. Using .class (Compile-time)   
       Class<String> cls = String.class;
       
   3. Using getClass() (Runtime object) 
       String s = "Hello";
       Class<?> cls = s.getClass();
    
   how to do reflection of classes
   --------------------------------------------
   Class<?> cls = Class.forName("Employee");
   Object obj = cls.getDeclaredConstructor().newInstance();
   Method[] method = cls.getMethod(); // it return all public methods.
   Method[] method = cls.getDeclaredMethods(); // it return all public and private methods of Employee class.
   Field[] field = cls.getFields(); // it return all public of Employee class.
   Field[] field = cls.getDeclaredFields(); // it return all public and private fields of Employee class. 
   
   Reflection of Constructor :
   --------------------------------------
   Constructor<Employee> object = Employee.class.getDeclaredConstructor(); 
   Employee ref_obj = object.newInstance();
 
 
 What is Annotation
 ============================================================
 -> Annotation is a special tag/metadata in Java that gives extra information about code to the compiler, JVM, or frameworks.
 -> It does NOT change program logic directly
 -> It helps tools & frameworks understand your code
 
         @Override
         public String toString() {
             return "Hello";
         }
   Here @Override tells the compiler:
  ‚ÄúThis method overrides a parent method‚Äù
  
  @Override	           Method override check
  @Deprecated	       Marks old method
  @SuppressWarnings    Suppress warnings
  @FunctionalInterface	Only one abstract method
 
 @Target :
 - This annotation will restrict, where to use annotation.
   Either at method or constructor or fields.
   
   @Target(ElementType.METHOD)
   public @interface override(){}
 
   @Target({ElementType.CONSTRUCTOR, ElementType.METHOD})
   public @interface SafeVarargs(){}
   
   
 What is Exception
 ======================================================================
 -> Exception is an unwanted or unexpected event that is occur during the execution of program.
 -> It will disturb the normal flow of program.
 -> It create the Exception Object, which contains the information about the Error like 
      . Type of Exception or message
      . Stack trace etc
 -> Runtime system use this Exception Object and find the class which can handle it.
 
 
  üîÅ Exception Handling Flow (Detailed Diagram)
 ------------------------------------------------------------
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   Method Starts   ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
                  ‚ñº
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ   try block code  ‚îÇ
        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚îÇ                       ‚îÇ
   No Exception            Exception Occurs
        ‚îÇ                       ‚îÇ
        ‚ñº                       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Skip all catch ‚îÇ     ‚îÇ JVM creates object  ‚îÇ
‚îÇ blocks         ‚îÇ     ‚îÇ (Exception obj)     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                          ‚îÇ
        ‚ñº                          ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ finally executes   ‚îÇ   ‚îÇ Search matching catch‚îÇ
‚îÇ                    ‚îÇ   ‚îÇ (top ‚Üí bottom)       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
          ‚îÇ                          ‚îÇ
          ‚ñº               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ Match found?        ‚îÇ
   ‚îÇ Normal End    ‚îÇ      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò              ‚îÇ
                         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                         ‚îÇ Yes               ‚îÇ No
                         ‚ñº                   ‚ñº
               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
               ‚îÇ Execute catch    ‚îÇ   ‚îÇ Exception propaga- ‚îÇ
               ‚îÇ block            ‚îÇ   ‚îÇ tes to caller      ‚îÇ
               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ                      ‚îÇ
                         ‚ñº                      ‚ñº
               ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
               ‚îÇ finally executes ‚îÇ   ‚îÇ Caller has try?   ‚îÇ
               ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ                      ‚îÇ
                         ‚ñº              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ Yes             ‚îÇ No
                  ‚îÇ Method Ends   ‚îÇ     ‚ñº                 ‚ñº
                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                     ‚îÇ Handle there ‚îÇ ‚îÇ JVM terminates ‚îÇ
                                     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ program        ‚îÇ
                                                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
 
 
 
   üå≥ Java Exception Hierarchy Diagram
   -----------------------------------------------------------
                                  java.lang.Object
                                      ‚îÇ
                               java.lang.Throwable
                                      ‚îÇ
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ                                                ‚îÇ
        java.lang.Error                                java.lang.Exception
              ‚îÇ                                                ‚îÇ
   (JVM / System level issues)                     (Application level issues)
              ‚îÇ                                                ‚îÇ
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ          ‚îÇ              ‚îÇ                 ‚îÇ                               ‚îÇ
OutOfMemoryError  StackOverflowError     RuntimeException               Checked Exceptions
                                            (Unchecked)                        ‚îÇ
                                                 ‚îÇ                              ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        IOException
         ‚îÇ               ‚îÇ              ‚îÇ        ‚îÇ              ‚îÇ        SQLException, ClassNotFoundException,InterruptedException,NoSuchMethodException
 NullPointerException  ArithmeticException  ClassCastException  IllegalArgumentException
                                                                      ‚îÇ
                                                          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                                   NumberFormatException   IllegalStateException
         ‚îÇ
         ‚îî‚îÄ‚îÄ IndexOutOfBoundsException
                    ‚îÇ
         ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ArrayIndexOutOfBoundsException
 StringIndexOutOfBoundsException
                                                                         
 
 -> If it extends RuntimeException ‚Üí Unchecked
    If it extends Exception but NOT RuntimeException ‚Üí Checked                                                                         
    
   
  Different way to handle the exception 
  ---------------------------------------------------------------
  ‚úÖ 1. try ‚Äì catch
  
         try {
           int a = 10 / 0;
        } catch (ArithmeticException e) {
           System.out.println("Cannot divide by zero");
       }
        
  ‚úÖ 2. try ‚Äì catch ‚Äì finally
  
       try {
         int a = 10 / 2;
       } catch (Exception e) {
              e.printStackTrace();
       } finally {
            System.out.println("Always executed");
       }
  
  ‚úÖ 3. try ‚Äì finally (No catch)
  
       try {
           int a = 10 / 0;
       } finally {
             System.out.println("Cleanup code");
       }
            
  ‚úÖ 4. Multiple catch blocks
  
       try {
           String s = null;
           s.length();
        } catch (NullPointerException e) {
              System.out.println("Null value");
        } catch (Exception e) {
               System.out.println("General exception");
        }
      ‚úî Order: child ‚Üí parent 
      
  ‚úÖ 5. Multi-catch (Java 7+) 
   
        try {
            int a = Integer.parseInt("abc");
        } catch (NumberFormatException | NullPointerException e) {
             System.out.println("Invalid input");
        }
        
  ‚úÖ 6. throws keyword
  
        void readFile() throws IOException {
              FileReader fr = new FileReader("a.txt");
        }
      ‚úî Common for checked exceptions   
  
  ‚úÖ 7. throw keyword
  
        if (age < 18) {
            throw new IllegalArgumentException("Not eligible");
        }
  
  ‚úÖ 8. Custom Exception
           Create your own exception
           
           class InvalidAgeException extends Exception {
               InvalidAgeException(String msg) {
                    super(msg);
               }
           }
           
  ‚úÖ 9. Try-with-resources   
         Best way to handle resource exceptions
         
         try (FileReader fr = new FileReader("a.txt")) {
                   // use resource
         } catch (IOException e) {
                  e.printStackTrace();
         }
        ‚úî Auto-closes resources
        
  üß† One-shot Memory Trick
      Handle ‚Üí try-catch
      Cleanup ‚Üí finally / try-with-resources
      Pass ‚Üí throws
      Create ‚Üí throw / custom exception
                   
 -> JVM throws exceptions automatically during runtime errors, whereas the throw keyword is used by the programmer
    to explicitly throw an exception based on application logic. 
   
  Example: 
     JVM throws exception
        int a = 10 / 0;   // JVM throws ArithmeticException 
     throw keyword used by Developer
         if (balance < amount) {
             throw new IllegalArgumentException("Insufficient balance");
         }
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
 
